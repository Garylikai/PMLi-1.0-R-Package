<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />

<meta name="viewport" content="width=device-width, initial-scale=1" />

<meta name="author" content="Kai Li" />

<meta name="date" content="2021-05-05" />

<title>PMLi Package User Manual (Version 1.0)</title>

<script>// Hide empty <a> tag within highlighted CodeBlock for screen reader accessibility (see https://github.com/jgm/pandoc/issues/6352#issuecomment-626106786) -->
// v0.0.1
// Written by JooYoung Seo (jooyoung@psu.edu) and Atsushi Yasumoto on June 1st, 2020.

document.addEventListener('DOMContentLoaded', function() {
  const codeList = document.getElementsByClassName("sourceCode");
  for (var i = 0; i < codeList.length; i++) {
    var linkList = codeList[i].getElementsByTagName('a');
    for (var j = 0; j < linkList.length; j++) {
      if (linkList[j].innerHTML === "") {
        linkList[j].setAttribute('aria-hidden', 'true');
      }
    }
  }
});
</script>

<style type="text/css">
  code{white-space: pre-wrap;}
  span.smallcaps{font-variant: small-caps;}
  span.underline{text-decoration: underline;}
  div.column{display: inline-block; vertical-align: top; width: 50%;}
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  ul.task-list{list-style: none;}
    </style>


<style type="text/css">
  code {
    white-space: pre;
  }
  .sourceCode {
    overflow: visible;
  }
</style>
<style type="text/css" data-origin="pandoc">
code.sourceCode > span { display: inline-block; line-height: 1.25; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */

</style>
<script>
// apply pandoc div.sourceCode style to pre.sourceCode instead
(function() {
  var sheets = document.styleSheets;
  for (var i = 0; i < sheets.length; i++) {
    if (sheets[i].ownerNode.dataset["origin"] !== "pandoc") continue;
    try { var rules = sheets[i].cssRules; } catch (e) { continue; }
    for (var j = 0; j < rules.length; j++) {
      var rule = rules[j];
      // check if there is a div.sourceCode rule
      if (rule.type !== rule.STYLE_RULE || rule.selectorText !== "div.sourceCode") continue;
      var style = rule.style.cssText;
      // check if color or background-color is set
      if (rule.style.color === '' && rule.style.backgroundColor === '') continue;
      // replace div.sourceCode by a pre.sourceCode rule
      sheets[i].deleteRule(j);
      sheets[i].insertRule('pre.sourceCode{' + style + '}', j);
    }
  }
})();
</script>




<style type="text/css">body {
background-color: #fff;
margin: 1em auto;
max-width: 700px;
overflow: visible;
padding-left: 2em;
padding-right: 2em;
font-family: "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;
font-size: 14px;
line-height: 1.35;
}
#TOC {
clear: both;
margin: 0 0 10px 10px;
padding: 4px;
width: 400px;
border: 1px solid #CCCCCC;
border-radius: 5px;
background-color: #f6f6f6;
font-size: 13px;
line-height: 1.3;
}
#TOC .toctitle {
font-weight: bold;
font-size: 15px;
margin-left: 5px;
}
#TOC ul {
padding-left: 40px;
margin-left: -1.5em;
margin-top: 5px;
margin-bottom: 5px;
}
#TOC ul ul {
margin-left: -2em;
}
#TOC li {
line-height: 16px;
}
table {
margin: 1em auto;
border-width: 1px;
border-color: #DDDDDD;
border-style: outset;
border-collapse: collapse;
}
table th {
border-width: 2px;
padding: 5px;
border-style: inset;
}
table td {
border-width: 1px;
border-style: inset;
line-height: 18px;
padding: 5px 5px;
}
table, table th, table td {
border-left-style: none;
border-right-style: none;
}
table thead, table tr.even {
background-color: #f7f7f7;
}
p {
margin: 0.5em 0;
}
blockquote {
background-color: #f6f6f6;
padding: 0.25em 0.75em;
}
hr {
border-style: solid;
border: none;
border-top: 1px solid #777;
margin: 28px 0;
}
dl {
margin-left: 0;
}
dl dd {
margin-bottom: 13px;
margin-left: 13px;
}
dl dt {
font-weight: bold;
}
ul {
margin-top: 0;
}
ul li {
list-style: circle outside;
}
ul ul {
margin-bottom: 0;
}
pre, code {
background-color: #f7f7f7;
border-radius: 3px;
color: #333;
white-space: pre-wrap; 
}
pre {
border-radius: 3px;
margin: 5px 0px 10px 0px;
padding: 10px;
}
pre:not([class]) {
background-color: #f7f7f7;
}
code {
font-family: Consolas, Monaco, 'Courier New', monospace;
font-size: 85%;
}
p > code, li > code {
padding: 2px 0px;
}
div.figure {
text-align: center;
}
img {
background-color: #FFFFFF;
padding: 2px;
border: 1px solid #DDDDDD;
border-radius: 3px;
border: 1px solid #CCCCCC;
margin: 0 5px;
}
h1 {
margin-top: 0;
font-size: 35px;
line-height: 40px;
}
h2 {
border-bottom: 4px solid #f7f7f7;
padding-top: 10px;
padding-bottom: 2px;
font-size: 145%;
}
h3 {
border-bottom: 2px solid #f7f7f7;
padding-top: 10px;
font-size: 120%;
}
h4 {
border-bottom: 1px solid #f7f7f7;
margin-left: 8px;
font-size: 105%;
}
h5, h6 {
border-bottom: 1px solid #ccc;
font-size: 105%;
}
a {
color: #0033dd;
text-decoration: none;
}
a:hover {
color: #6666ff; }
a:visited {
color: #800080; }
a:visited:hover {
color: #BB00BB; }
a[href^="http:"] {
text-decoration: underline; }
a[href^="https:"] {
text-decoration: underline; }

code > span.kw { color: #555; font-weight: bold; } 
code > span.dt { color: #902000; } 
code > span.dv { color: #40a070; } 
code > span.bn { color: #d14; } 
code > span.fl { color: #d14; } 
code > span.ch { color: #d14; } 
code > span.st { color: #d14; } 
code > span.co { color: #888888; font-style: italic; } 
code > span.ot { color: #007020; } 
code > span.al { color: #ff0000; font-weight: bold; } 
code > span.fu { color: #900; font-weight: bold; } 
code > span.er { color: #a61717; background-color: #e3d2d2; } 
</style>




</head>

<body>




<h1 class="title toc-ignore">PMLi Package User Manual (Version 1.0)</h1>
<h4 class="author">Kai Li</h4>
<h4 class="date">2021-05-05</h4>



<div id="package-info" class="section level2">
<h2>Package Info</h2>
<p>The user manual is designed for users of the <code>PMLi</code> package. This <code>R</code> package was created as a project for AMS 597: Statistical Computing, Spring 2021, in Stony Brook University. <code>PMLi</code> contains statistical procedures to mainly analyze partially matched samples - an experimental design based on independent samples and matched pairs designs. For example, in clinical studies, a medical researcher may be interested in comparing two methods, call them methods A and B, for measuring cardiac output. If no missing value is present in the samples, the experimental design is called matched pairs design. Regular hypothesis testing procedures for matched pairs design, such as paired t-test method, can test the null hypothesis of the mean difference between two sets of paired observations. However, in reality, data has missing values for some reason. Appropriate statistical approaches are required for partially matched pairs. The project also investigates the statistical methods for numerous exceptional cases related to partially matched samples. In particular, data inputs may not be partially matched samples but uncomplicated cases that can be analyzed using standard analysis procedures. Therefore, the package handles partially matched samples and corner cases where statistical approaches for partially matched samples may not be suitable.</p>
<p>The statistical procedures for partially matched samples discussed here are largely based on Kuan and Huang’s work <span class="citation">[<a href="#ref-kuan" role="doc-biblioref">1</a>]</span>. Prof. Pei Fen Kuan is the course instructor for AMS 597, Spring 2021. More information about Kuan and Huang’s work on partially matched samples can be found <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3717400/">here</a>. More information about the course AMS 597 can be found <a href="https://www.stonybrook.edu/commcms/ams/graduate/_courses/ams597.php">here</a>.</p>
</div>
<div id="package-installation" class="section level2">
<h2>Package Installation</h2>
<p>The <code>PMLi</code> package can be installed in <code>R</code> directly.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1"></a><span class="kw">install.packages</span>(<span class="st">&quot;PMLi_1.0.tar.gz&quot;</span>, <span class="dt">type =</span> <span class="st">&quot;source&quot;</span>)</span>
<span id="cb1-2"><a href="#cb1-2"></a><span class="kw">library</span>(PMLi)</span></code></pre></div>
</div>
<div id="more-background" class="section level2">
<h2>More Background</h2>
<p>Mathematically speaking, suppose that <span class="math inline">\(2n\)</span> samples of cardiac output, i.e., <span class="math inline">\(n\)</span> pairs of matched samples of cardiac output with missing values, are drawn from a subject population. Suppose that <span class="math inline">\(n_1\)</span> pairs of the samples are entirely matched. That is, the <span class="math inline">\(n_1\)</span> subject pairs do not have any missing cardiac output values. Further, suppose that <span class="math inline">\(n_2\)</span> and <span class="math inline">\(n_3\)</span> subject pairs have only missing cardiac output values for methods A and B, respectively. Then, the data for measuring cardiac output is an example of partially matched data.</p>
<p>It is also possible that <span class="math inline">\(n_4\)</span> pairs of the cardiac outputs are all missing. This scenario will not change the inherent characteristics of partially matched samples because the <span class="math inline">\(n_4\)</span> pairs of missing values can be omitted directly. A table illustration with general ordered partially matched samples is shown below. Note that in reality, the pairs are typically not ordered like the following.</p>
<table>
<caption>Demonstration of Partially Matched Samples</caption>
<thead>
<tr class="header">
<th align="center">Pair <span class="math inline">\(1\)</span></th>
<th align="center">Pair <span class="math inline">\(2\)</span></th>
<th>…</th>
<th align="center">Pair <span class="math inline">\(n_1\)</span></th>
<th align="center">Pair <span class="math inline">\(n_1+1\)</span></th>
<th>…</th>
<th align="center">Pair <span class="math inline">\(n_1+n_2\)</span></th>
<th align="center">Pair <span class="math inline">\(n_1+n_2+1\)</span></th>
<th>…</th>
<th align="center">Pair <span class="math inline">\(n_1+n_2+n_3\)</span></th>
<th align="center">Pair <span class="math inline">\(n_1+n_2+n_3+1\)</span></th>
<th>…</th>
<th align="center">Pair <span class="math inline">\(n\)</span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="center"><span class="math inline">\(x_1\)</span></td>
<td align="center"><span class="math inline">\(x_2\)</span></td>
<td>…</td>
<td align="center"><span class="math inline">\(x_{n_1}\)</span></td>
<td align="center"><span class="math inline">\(x_{n_1+1}\)</span></td>
<td>…</td>
<td align="center"><span class="math inline">\(x_{n_1+n_2}\)</span></td>
<td align="center">NA</td>
<td>…</td>
<td align="center">NA</td>
<td align="center">NA</td>
<td>…</td>
<td align="center">NA</td>
</tr>
<tr class="even">
<td align="center"><span class="math inline">\(y_1\)</span></td>
<td align="center"><span class="math inline">\(y_2\)</span></td>
<td>…</td>
<td align="center"><span class="math inline">\(y_{n_1}\)</span></td>
<td align="center">NA</td>
<td>…</td>
<td align="center">NA</td>
<td align="center"><span class="math inline">\(y_{n_1+n_2+1}\)</span></td>
<td>…</td>
<td align="center"><span class="math inline">\(y_{n_1+n_2+n_3}\)</span></td>
<td align="center">NA</td>
<td>…</td>
<td align="center">NA</td>
</tr>
</tbody>
</table>
<p>Pair <span class="math inline">\(n\)</span> is, in fact, Pair <span class="math inline">\(n_1+n_2+n_3+n_4\)</span>. Denote the second and the third rows of the table above Sample 1 and Sample 2, correspondingly. Then, Method A and Method B are Sample 1 and Sample 2, respectively, in the cardiac output example. Furthermore, denote the subset of data <code>data1</code> with <span class="math inline">\(n_1\)</span> fully matched pairs, the subset of data <code>data2</code> with <span class="math inline">\(n_2\)</span> Sample 1 observations paired with missing values, the subset of data <code>data3</code> with <span class="math inline">\(n_3\)</span> Sample 2 observations paired with missing values, and the subset of data <code>data4</code> with <span class="math inline">\(n_4\)</span> matched NA observations. In particular, partially matched samples should be either a combined data of <code>data1</code>, <code>data2</code>, and <code>data3</code> or a combined data of <code>data1</code>, <code>data2</code>, <code>data3</code>, and <code>data4</code>. Again, the partially matched pairs between and within datasets can be in any order.</p>
<p>Partially matched samples is an experimental design that can be considered as a combination of the following two experimental designs <span class="citation">[<a href="#ref-kuan" role="doc-biblioref">1</a>]</span>:</p>
<ul>
<li><span class="math inline">\(n_1\)</span> matched pairs or repeated measures (<code>data1</code>)</li>
<li>independent groups with <span class="math inline">\(n_2\)</span> and <span class="math inline">\(n_3\)</span> per group (Sample 1 from <code>data2</code> and Sample 2 from <code>data3</code>), where both group’s experimental designs intend to estimate the same parameter (e.g., difference of means of the two groups is 0)</li>
</ul>
<p>Again, <code>data4</code> with <span class="math inline">\(n_4\)</span> pairs of missing values is discarded in hypothesis testing since it is only meaningful for the completeness of justifying the data structure. Now, it is ready to move on to some details of implementation.</p>
</div>
<div id="implementation-details-for-special-cases-related-to-partially-matched-samples" class="section level2">
<h2>Implementation Details for Special Cases Related to Partially Matched Samples<a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a></h2>
<p>All functions in the <code>PMLi</code> package will verify whether the experimental design of the input dataset is partially matched samples. If the dataset is not partially matched, appropriate alternative testing procedures will be used, depending on the dataset’s structure. The sample dataset <code>pm</code> in the <code>PMLi</code> package is borrowed to clarify the scenarios below.</p>
<div id="data-input" class="section level3">
<h3>0. Data Input</h3>
<p><code>pm</code> is the sample dataset that is lazily loaded already. The dataset can be retrieved directly.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1"></a>data &lt;-<span class="st"> </span>pm</span></code></pre></div>
</div>
<div id="n_10-n_20-n_30-n_40-n0" class="section level3">
<h3>1. <span class="math inline">\(n_1=0,\, n_2=0,\, n_3=0,\, n_4=0\, (n=0)\)</span></h3>
<p>The first case concerns an empty dataset. In this package, inputting an empty dataset will return an error message without performing any hypothesis tests.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1"></a><span class="cf">if</span>(<span class="kw">length</span>(data) <span class="op">==</span><span class="st"> </span><span class="dv">0</span>){</span>
<span id="cb3-2"><a href="#cb3-2"></a>  <span class="kw">stop</span>(<span class="st">&quot;The data is empty. Please input a nonempty dataset to begin.</span><span class="ch">\n</span><span class="st">&quot;</span>)</span>
<span id="cb3-3"><a href="#cb3-3"></a>}</span></code></pre></div>
<p>If the input argument is a vector, an error message will also be returned because the data does not follow a matched sample design. The data argument of all the functions in <code>PMLi</code> accepts either a <span class="math inline">\(2\times n\)</span> or an <span class="math inline">\(n\times 2\)</span> data frame or matrix. Here, an <span class="math inline">\(n\times 2\)</span> data frame or matrix input will be converted into a <span class="math inline">\(2\times n\)</span> data frame to align with the data structure demonstrated in the table. Inputting other dimensions, such as an <span class="math inline">\(n\times 5\)</span> matrix, will produce an error message.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1"></a><span class="cf">if</span>(<span class="kw">is.vector</span>(data)){</span>
<span id="cb4-2"><a href="#cb4-2"></a>    <span class="kw">stop</span>(<span class="st">&quot;The data is a vector. Please input a nonempty dataset to begin.</span><span class="ch">\n</span><span class="st">&quot;</span>)</span>
<span id="cb4-3"><a href="#cb4-3"></a>}<span class="cf">else</span> <span class="cf">if</span>(<span class="kw">length</span>(data[<span class="dv">1</span>, ]) <span class="op">==</span><span class="st"> </span><span class="dv">2</span>){</span>
<span id="cb4-4"><a href="#cb4-4"></a>  data &lt;-<span class="st"> </span><span class="kw">as.data.frame</span>(<span class="kw">t</span>(data))</span>
<span id="cb4-5"><a href="#cb4-5"></a>}<span class="cf">else</span> <span class="cf">if</span>(<span class="kw">length</span>(data[, <span class="dv">1</span>]) <span class="op">==</span><span class="st"> </span><span class="dv">2</span>){</span>
<span id="cb4-6"><a href="#cb4-6"></a>  data &lt;-<span class="st"> </span><span class="kw">as.data.frame</span>(data)</span>
<span id="cb4-7"><a href="#cb4-7"></a>}<span class="cf">else</span>{</span>
<span id="cb4-8"><a href="#cb4-8"></a>  <span class="kw">stop</span>(<span class="st">&quot;The data inputted is not partially matched.</span><span class="ch">\n</span><span class="st">&quot;</span>)</span>
<span id="cb4-9"><a href="#cb4-9"></a>}</span></code></pre></div>
<p>After verifying the input data dimension, separate the complete input data into subsets of data named <code>data1</code>, <code>data2</code>, and <code>data3</code> with the same notation illustrated before. Define <code>n1</code>, <code>n2</code>, and <code>n3</code> to be the corresponding number of paired samples in the implementation so that the exceptional cases can be described easily.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1"></a>data1 &lt;-<span class="st"> </span>data[<span class="kw">which</span>(<span class="kw">is.na</span>(data[<span class="dv">1</span>, ]) <span class="op">==</span><span class="st"> </span><span class="ot">FALSE</span> <span class="op">&amp;</span><span class="st"> </span><span class="kw">is.na</span>(data[<span class="dv">2</span>, ]) <span class="op">==</span><span class="st"> </span><span class="ot">FALSE</span>)]</span>
<span id="cb5-2"><a href="#cb5-2"></a>data2 &lt;-<span class="st"> </span>data[<span class="kw">which</span>(<span class="kw">is.na</span>(data[<span class="dv">1</span>, ]) <span class="op">==</span><span class="st"> </span><span class="ot">FALSE</span> <span class="op">&amp;</span><span class="st"> </span><span class="kw">is.na</span>(data[<span class="dv">2</span>, ]))]</span>
<span id="cb5-3"><a href="#cb5-3"></a>data3 &lt;-<span class="st"> </span>data[<span class="kw">which</span>(<span class="kw">is.na</span>(data[<span class="dv">1</span>, ]) <span class="op">&amp;</span><span class="st"> </span><span class="kw">is.na</span>(data[<span class="dv">2</span>, ]) <span class="op">==</span><span class="st"> </span><span class="ot">FALSE</span>)]</span>
<span id="cb5-4"><a href="#cb5-4"></a></span>
<span id="cb5-5"><a href="#cb5-5"></a>n1 &lt;-<span class="st"> </span><span class="kw">length</span>(data1)</span>
<span id="cb5-6"><a href="#cb5-6"></a>n2 &lt;-<span class="st"> </span><span class="kw">length</span>(data2)</span>
<span id="cb5-7"><a href="#cb5-7"></a>n3 &lt;-<span class="st"> </span><span class="kw">length</span>(data3)</span></code></pre></div>
</div>
<div id="n_10-n_20-n_30-n_40-n0-1" class="section level3">
<h3>2. <span class="math inline">\(n_1=0,\, n_2=0,\, n_3=0,\, n_4&gt;0\, (n&gt;0)\)</span></h3>
<p>The second case is an extension of the first case: only missing value pairs are inputted. Note that the first case is examined before the second case. Therefore, the only possibility that corresponds to the second case is a dataset with only missing data pairs, which will return an error message. In future implementations, because <code>data4</code> is not of any interest, whether <code>data4</code> is empty or not will not be considered individually.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb6-1"><a href="#cb6-1"></a><span class="cf">if</span>(n1 <span class="op">==</span><span class="st"> </span><span class="dv">0</span> <span class="op">&amp;</span><span class="st"> </span>n2 <span class="op">==</span><span class="st"> </span><span class="dv">0</span> <span class="op">&amp;</span><span class="st"> </span>n3 <span class="op">==</span><span class="st"> </span><span class="dv">0</span>){</span>
<span id="cb6-2"><a href="#cb6-2"></a>    <span class="kw">stop</span>(<span class="st">&quot;The data only contains missing values. Please input a valid dataset</span></span>
<span id="cb6-3"><a href="#cb6-3"></a><span class="st">          to begin.</span><span class="ch">\n</span><span class="st">&quot;</span>)</span>
<span id="cb6-4"><a href="#cb6-4"></a>}</span></code></pre></div>
</div>
<div id="n_10-n_20-n_30" class="section level3">
<h3>3. <span class="math inline">\(n_1=0,\, n_2&gt;0,\, n_3=0\)</span></h3>
<p>The third case considers that <span class="math inline">\(n_2\)</span> pairs of samples are inputted, with all missing values in Sample 2. This scenario matches a data input of <code>data2</code>. In this case, the one-sample Wilcoxon signed rank test method will be used if the Shapiro-Wilk test for the first sample of <code>data2</code> is significant. Otherwise, the one-sample t-test method will be used.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1"></a><span class="cf">if</span>(n1 <span class="op">==</span><span class="st"> </span><span class="dv">0</span> <span class="op">&amp;</span><span class="st"> </span>n2 <span class="op">&gt;</span><span class="st"> </span><span class="dv">0</span> <span class="op">&amp;</span><span class="st"> </span>n3 <span class="op">==</span><span class="st"> </span><span class="dv">0</span>){</span>
<span id="cb7-2"><a href="#cb7-2"></a>  <span class="cf">if</span>(<span class="kw">shapiro.test</span>(<span class="kw">unlist</span>(data2[<span class="dv">1</span>, ]))<span class="op">$</span>p.value <span class="op">&lt;=</span><span class="st"> </span><span class="fl">0.05</span>){</span>
<span id="cb7-3"><a href="#cb7-3"></a>    test &lt;-<span class="st"> </span><span class="kw">wilcox.test</span>(<span class="kw">unlist</span>(data2[<span class="dv">1</span>, ]), <span class="dt">alternative =</span> alternative, <span class="dt">mu =</span> mu,</span>
<span id="cb7-4"><a href="#cb7-4"></a>                        <span class="dt">paired =</span> <span class="ot">FALSE</span>, <span class="dt">conf.int =</span> <span class="ot">TRUE</span>, <span class="dt">conf.level =</span> conf.level)</span>
<span id="cb7-5"><a href="#cb7-5"></a>  }<span class="cf">else</span>{</span>
<span id="cb7-6"><a href="#cb7-6"></a>    test &lt;-<span class="st"> </span><span class="kw">t.test</span>(data2[<span class="dv">1</span>, ], <span class="dt">alternative =</span> alternative, <span class="dt">mu =</span> mu, </span>
<span id="cb7-7"><a href="#cb7-7"></a>                   <span class="dt">conf.level =</span> conf.level, <span class="dt">paired =</span> <span class="ot">FALSE</span>, <span class="dt">var.equal =</span> <span class="ot">FALSE</span>)</span>
<span id="cb7-8"><a href="#cb7-8"></a>  }</span>
<span id="cb7-9"><a href="#cb7-9"></a>}</span></code></pre></div>
</div>
<div id="n_10-n_20-n_30-1" class="section level3">
<h3>4. <span class="math inline">\(n_1=0,\, n_2=0,\, n_3&gt;0\)</span></h3>
<p>This case is identical to the third case except that all Sample 1 values of <code>data3</code> are missing.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb8-1"><a href="#cb8-1"></a><span class="cf">if</span>(n1 <span class="op">==</span><span class="st"> </span><span class="dv">0</span> <span class="op">&amp;</span><span class="st"> </span>n2 <span class="op">==</span><span class="st"> </span><span class="dv">0</span> <span class="op">&amp;</span><span class="st"> </span>n3 <span class="op">&gt;</span><span class="st"> </span><span class="dv">0</span>){</span>
<span id="cb8-2"><a href="#cb8-2"></a>  <span class="cf">if</span>(<span class="kw">shapiro.test</span>(<span class="kw">unlist</span>(data3[<span class="dv">2</span>, ]))<span class="op">$</span>p.value <span class="op">&lt;=</span><span class="st"> </span><span class="fl">0.05</span>){</span>
<span id="cb8-3"><a href="#cb8-3"></a>    test &lt;-<span class="st"> </span><span class="kw">wilcox.test</span>(<span class="kw">unlist</span>(data3[<span class="dv">2</span>, ]), <span class="dt">alternative =</span> alternative, <span class="dt">mu =</span> mu,</span>
<span id="cb8-4"><a href="#cb8-4"></a>                        <span class="dt">paired =</span> <span class="ot">FALSE</span>, <span class="dt">conf.int =</span> <span class="ot">TRUE</span>, <span class="dt">conf.level =</span> conf.level)</span>
<span id="cb8-5"><a href="#cb8-5"></a>  }<span class="cf">else</span>{</span>
<span id="cb8-6"><a href="#cb8-6"></a>    test &lt;-<span class="st"> </span><span class="kw">t.test</span>(data3[<span class="dv">2</span>, ], <span class="dt">alternative =</span> alternative, <span class="dt">mu =</span> mu, </span>
<span id="cb8-7"><a href="#cb8-7"></a>                   <span class="dt">conf.level =</span> conf.level, <span class="dt">paired =</span> <span class="ot">FALSE</span>, <span class="dt">var.equal =</span> <span class="ot">FALSE</span>)</span>
<span id="cb8-8"><a href="#cb8-8"></a>  }</span>
<span id="cb8-9"><a href="#cb8-9"></a>}</span></code></pre></div>
</div>
<div id="n_10-n_20-n_30-2" class="section level3">
<h3>5. <span class="math inline">\(n_1=0,\, n_2&gt;0,\, n_3&gt;0\)</span></h3>
<p>Now suppose that no matched pairs are found in the data input but only pairs of (observation, missing) and (missing, observation). This case corresponds to an input of a combined dataset of <code>data2</code> and <code>data3</code>. Here, treating the first and the second samples of <code>data2</code> and <code>data3</code>, respectively, as independent groups is more appropriate. Hence, the two-sample Wilcoxon rank sum test will be used if the Shapiro-Wilk test is significant for at least one of the samples. Otherwise, the two-sample t-test method will be used. Specifically, if the F Test to compare two variances is significant, the two-sample t-test method with unequal variance assumption will be used. If not, the two-sample t-test method with equal variance assumption will be used.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb9-1"><a href="#cb9-1"></a><span class="cf">if</span>(n1 <span class="op">==</span><span class="st"> </span><span class="dv">0</span> <span class="op">&amp;</span><span class="st"> </span>n2 <span class="op">&gt;</span><span class="st"> </span><span class="dv">0</span> <span class="op">&amp;</span><span class="st"> </span>n3 <span class="op">&gt;</span><span class="st"> </span><span class="dv">0</span>){</span>
<span id="cb9-2"><a href="#cb9-2"></a>  <span class="cf">if</span>(<span class="kw">shapiro.test</span>(<span class="kw">unlist</span>(data2[<span class="dv">1</span>, ]))<span class="op">$</span>p.value <span class="op">&lt;=</span><span class="st"> </span><span class="fl">0.05</span> <span class="op">|</span><span class="st"> </span></span>
<span id="cb9-3"><a href="#cb9-3"></a><span class="st">       </span><span class="kw">shapiro.test</span>(<span class="kw">unlist</span>(data3[<span class="dv">2</span>, ]))<span class="op">$</span>p.value <span class="op">&lt;=</span><span class="st"> </span><span class="fl">0.05</span>){</span>
<span id="cb9-4"><a href="#cb9-4"></a>      test &lt;-<span class="st"> </span><span class="kw">wilcox.test</span>(<span class="kw">unlist</span>(data2[<span class="dv">1</span>, ]), <span class="kw">unlist</span>(data3[<span class="dv">2</span>, ]),</span>
<span id="cb9-5"><a href="#cb9-5"></a>                          <span class="dt">alternative =</span> alternative, <span class="dt">mu =</span> mu, <span class="dt">paired =</span> <span class="ot">FALSE</span>, </span>
<span id="cb9-6"><a href="#cb9-6"></a>                          <span class="dt">conf.int =</span> <span class="ot">TRUE</span>, <span class="dt">conf.level =</span> conf.level)</span>
<span id="cb9-7"><a href="#cb9-7"></a>  }<span class="cf">else</span>{</span>
<span id="cb9-8"><a href="#cb9-8"></a>    <span class="cf">if</span>(<span class="kw">var.test</span>(<span class="kw">unlist</span>(data2[<span class="dv">1</span>, ]), <span class="kw">unlist</span>(data3[<span class="dv">2</span>, ]))<span class="op">$</span>p.value <span class="op">&lt;=</span><span class="st"> </span><span class="fl">0.05</span>){</span>
<span id="cb9-9"><a href="#cb9-9"></a>      test &lt;-<span class="st"> </span><span class="kw">t.test</span>(data2[<span class="dv">1</span>, ], data3[<span class="dv">2</span>, ], <span class="dt">alternative =</span> alternative, <span class="dt">mu =</span> mu,</span>
<span id="cb9-10"><a href="#cb9-10"></a>                     <span class="dt">conf.level =</span> conf.level, <span class="dt">paired =</span> <span class="ot">FALSE</span>, <span class="dt">var.equal =</span> <span class="ot">FALSE</span>)</span>
<span id="cb9-11"><a href="#cb9-11"></a>    }<span class="cf">else</span>{</span>
<span id="cb9-12"><a href="#cb9-12"></a>      test &lt;-<span class="st"> </span><span class="kw">t.test</span>(data2[<span class="dv">1</span>, ], data3[<span class="dv">2</span>, ], <span class="dt">alternative =</span> alternative, <span class="dt">mu =</span> mu,</span>
<span id="cb9-13"><a href="#cb9-13"></a>                     <span class="dt">conf.level =</span> conf.level, <span class="dt">paired =</span> <span class="ot">FALSE</span>, <span class="dt">var.equal =</span> <span class="ot">TRUE</span>)</span>
<span id="cb9-14"><a href="#cb9-14"></a>    }</span>
<span id="cb9-15"><a href="#cb9-15"></a>  }</span>
<span id="cb9-16"><a href="#cb9-16"></a>}</span></code></pre></div>
</div>
<div id="n_1n-n_20-n_30" class="section level3">
<h3>6. <span class="math inline">\(n_1=n,\, n_2=0,\, n_3=0\)</span></h3>
<p>Consider the case that the input samples are complete (<code>data1</code>). Here, treating the first and the second samples of <code>data1</code> as matched pairs is more appropriate. Hence, the Wilcoxon signed rank test method for matched pairs will be used if the Shapiro-Wilk test is significant for at least one of the samples. Otherwise, the matched t-test method will be used.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb10-1"><a href="#cb10-1"></a><span class="cf">if</span>(<span class="kw">length</span>(data) <span class="op">==</span><span class="st"> </span>n1){</span>
<span id="cb10-2"><a href="#cb10-2"></a>  <span class="cf">if</span>(<span class="kw">shapiro.test</span>(<span class="kw">unlist</span>(data1[<span class="dv">1</span>, ]))<span class="op">$</span>p.value <span class="op">&lt;=</span><span class="st"> </span><span class="fl">0.05</span> <span class="op">|</span></span>
<span id="cb10-3"><a href="#cb10-3"></a><span class="st">     </span><span class="kw">shapiro.test</span>(<span class="kw">unlist</span>(data1[<span class="dv">2</span>, ]))<span class="op">$</span>p.value <span class="op">&lt;=</span><span class="st"> </span><span class="fl">0.05</span>){</span>
<span id="cb10-4"><a href="#cb10-4"></a>    test &lt;-<span class="st"> </span><span class="kw">wilcox.test</span>(<span class="kw">unlist</span>(data1[<span class="dv">1</span>, ]), <span class="kw">unlist</span>(data1[<span class="dv">2</span>, ]),</span>
<span id="cb10-5"><a href="#cb10-5"></a>                        <span class="dt">alternative =</span> alternative, <span class="dt">mu =</span> mu, <span class="dt">paired =</span> <span class="ot">TRUE</span>,</span>
<span id="cb10-6"><a href="#cb10-6"></a>                        <span class="dt">conf.int =</span> <span class="ot">TRUE</span>, <span class="dt">conf.level =</span> conf.level)</span>
<span id="cb10-7"><a href="#cb10-7"></a>  }<span class="cf">else</span>{</span>
<span id="cb10-8"><a href="#cb10-8"></a>    test &lt;-<span class="st"> </span><span class="kw">t.test</span>(<span class="kw">unlist</span>(data1[<span class="dv">1</span>, ]), <span class="kw">unlist</span>(data1[<span class="dv">2</span>, ]), </span>
<span id="cb10-9"><a href="#cb10-9"></a>                   <span class="dt">alternative =</span> alternative, <span class="dt">mu =</span> mu, <span class="dt">conf.level =</span> conf.level,</span>
<span id="cb10-10"><a href="#cb10-10"></a>                   <span class="dt">paired =</span> <span class="ot">TRUE</span>, <span class="dt">var.equal =</span> <span class="ot">FALSE</span>)</span>
<span id="cb10-11"><a href="#cb10-11"></a>  }</span>
<span id="cb10-12"><a href="#cb10-12"></a>}</span></code></pre></div>
</div>
<div id="n_10-n_20-n_30-3" class="section level3">
<h3>7. <span class="math inline">\(n_1&gt;0,\, n_2&gt;0,\, n_3=0\)</span></h3>
<p>In this special case, the dataset input is a combination of <code>data1</code> and <code>data2</code>. There are two choices to analyze the data if only standard complete analysis procedures are given:</p>
<ul>
<li>Only analyze the <span class="math inline">\(n_1\)</span> samples <code>data1</code> using paired-sample methods.</li>
<li>Treat <span class="math inline">\(n_1+n_2\)</span> Sample 1 observations (the first sample of the combined data of <code>data1</code> and <code>data2</code>) and <span class="math inline">\(n_1\)</span> Sample 2 observations (the second sample of <code>data1</code>) as two independent samples.</li>
</ul>
<p>In this package, both approaches will be run and outputted for the user’s information. The first approach can be handle using the procedures discussed in Case 6. The second approach can be dealt with using the methods discussed in Case 5 except for considering Sample 1 of the combined data of <code>data1</code> and <code>data2</code> and Sample 2 of <code>data1</code> as independent groups.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb11-1"><a href="#cb11-1"></a><span class="cf">if</span>(n1 <span class="op">&gt;</span><span class="st"> </span><span class="dv">0</span> <span class="op">&amp;</span><span class="st"> </span>n2 <span class="op">&gt;</span><span class="st"> </span><span class="dv">0</span> <span class="op">&amp;</span><span class="st"> </span>n3 <span class="op">==</span><span class="st"> </span><span class="dv">0</span>){</span>
<span id="cb11-2"><a href="#cb11-2"></a>  <span class="cf">if</span>(<span class="kw">shapiro.test</span>(<span class="kw">unlist</span>(data1[<span class="dv">1</span>, ]))<span class="op">$</span>p.value <span class="op">&lt;=</span><span class="st"> </span><span class="fl">0.05</span> <span class="op">|</span></span>
<span id="cb11-3"><a href="#cb11-3"></a><span class="st">     </span><span class="kw">shapiro.test</span>(<span class="kw">unlist</span>(data1[<span class="dv">2</span>, ]))<span class="op">$</span>p.value <span class="op">&lt;=</span><span class="st"> </span><span class="fl">0.05</span>){</span>
<span id="cb11-4"><a href="#cb11-4"></a>    test1 &lt;-<span class="st"> </span><span class="kw">wilcox.test</span>(<span class="kw">unlist</span>(data1[<span class="dv">1</span>, ]), <span class="kw">unlist</span>(data1[<span class="dv">2</span>, ]),</span>
<span id="cb11-5"><a href="#cb11-5"></a>                         <span class="dt">alternative =</span> alternative, <span class="dt">mu =</span> mu, <span class="dt">paired =</span> <span class="ot">TRUE</span>,</span>
<span id="cb11-6"><a href="#cb11-6"></a>                         <span class="dt">conf.int =</span> <span class="ot">TRUE</span>, <span class="dt">conf.level =</span> conf.level)</span>
<span id="cb11-7"><a href="#cb11-7"></a>    <span class="cf">if</span>(<span class="kw">shapiro.test</span>(<span class="kw">unlist</span>(<span class="kw">cbind</span>(data1, data2)[<span class="dv">1</span>, ]))<span class="op">$</span>p.value <span class="op">&lt;=</span><span class="st"> </span><span class="fl">0.05</span> <span class="op">|</span></span>
<span id="cb11-8"><a href="#cb11-8"></a><span class="st">       </span><span class="kw">shapiro.test</span>(<span class="kw">unlist</span>(data1[<span class="dv">2</span>, ]))<span class="op">$</span>p.value <span class="op">&lt;=</span><span class="st"> </span><span class="fl">0.05</span>){</span>
<span id="cb11-9"><a href="#cb11-9"></a>      test2 &lt;-<span class="st"> </span><span class="kw">wilcox.test</span>(<span class="kw">unlist</span>(<span class="kw">cbind</span>(data1, data2)[<span class="dv">1</span>, ]), <span class="kw">unlist</span>(data1[<span class="dv">2</span>, ]),</span>
<span id="cb11-10"><a href="#cb11-10"></a>                           <span class="dt">alternative =</span> alternative, <span class="dt">mu =</span> mu, <span class="dt">paired =</span> <span class="ot">FALSE</span>,</span>
<span id="cb11-11"><a href="#cb11-11"></a>                           <span class="dt">conf.int =</span> <span class="ot">TRUE</span>, <span class="dt">conf.level =</span> conf.level)  </span>
<span id="cb11-12"><a href="#cb11-12"></a>    }<span class="cf">else</span>{</span>
<span id="cb11-13"><a href="#cb11-13"></a>      <span class="cf">if</span>(<span class="kw">var.test</span>(<span class="kw">unlist</span>(<span class="kw">cbind</span>(data1, data2)[<span class="dv">1</span>, ]), <span class="kw">unlist</span>(data1[<span class="dv">2</span>, ]))<span class="op">$</span></span>
<span id="cb11-14"><a href="#cb11-14"></a><span class="st">         </span>p.value <span class="op">&lt;=</span><span class="st"> </span><span class="fl">0.05</span>){</span>
<span id="cb11-15"><a href="#cb11-15"></a>        test2 &lt;-<span class="st"> </span><span class="kw">t.test</span>(<span class="kw">cbind</span>(data1, data2)[<span class="dv">1</span>, ], data1[<span class="dv">2</span>, ],</span>
<span id="cb11-16"><a href="#cb11-16"></a>                        <span class="dt">alternative =</span> alternative, <span class="dt">mu =</span> mu, </span>
<span id="cb11-17"><a href="#cb11-17"></a>                        <span class="dt">conf.level =</span> conf.level, <span class="dt">paired =</span> <span class="ot">FALSE</span>,</span>
<span id="cb11-18"><a href="#cb11-18"></a>                        <span class="dt">var.equal =</span> <span class="ot">FALSE</span>)</span>
<span id="cb11-19"><a href="#cb11-19"></a>      }<span class="cf">else</span>{</span>
<span id="cb11-20"><a href="#cb11-20"></a>        test2 &lt;-<span class="st"> </span><span class="kw">t.test</span>(<span class="kw">cbind</span>(data1, data2)[<span class="dv">1</span>, ], data1[<span class="dv">2</span>, ],</span>
<span id="cb11-21"><a href="#cb11-21"></a>                        <span class="dt">alternative =</span> alternative, <span class="dt">mu =</span> mu, </span>
<span id="cb11-22"><a href="#cb11-22"></a>                        <span class="dt">conf.level =</span> conf.level, <span class="dt">paired =</span> <span class="ot">FALSE</span>, </span>
<span id="cb11-23"><a href="#cb11-23"></a>                        <span class="dt">var.equal =</span> <span class="ot">TRUE</span>)</span>
<span id="cb11-24"><a href="#cb11-24"></a>      }</span>
<span id="cb11-25"><a href="#cb11-25"></a>    }</span>
<span id="cb11-26"><a href="#cb11-26"></a>  }<span class="cf">else</span>{</span>
<span id="cb11-27"><a href="#cb11-27"></a>    test1 &lt;-<span class="st"> </span><span class="kw">t.test</span>(<span class="kw">unlist</span>(data1[<span class="dv">1</span>, ]), <span class="kw">unlist</span>(data1[<span class="dv">2</span>, ]), </span>
<span id="cb11-28"><a href="#cb11-28"></a>                    <span class="dt">alternative =</span> alternative, <span class="dt">mu =</span> mu, <span class="dt">conf.level =</span> conf.level,</span>
<span id="cb11-29"><a href="#cb11-29"></a>                    <span class="dt">paired =</span> <span class="ot">TRUE</span>, <span class="dt">var.equal =</span> <span class="ot">FALSE</span>)</span>
<span id="cb11-30"><a href="#cb11-30"></a>    <span class="cf">if</span>(<span class="kw">shapiro.test</span>(<span class="kw">unlist</span>(<span class="kw">cbind</span>(data1, data2)[<span class="dv">1</span>, ]))<span class="op">$</span>p.value <span class="op">&lt;=</span><span class="st"> </span><span class="fl">0.05</span> <span class="op">|</span></span>
<span id="cb11-31"><a href="#cb11-31"></a><span class="st">       </span><span class="kw">shapiro.test</span>(<span class="kw">unlist</span>(data1[<span class="dv">2</span>, ]))<span class="op">$</span>p.value <span class="op">&lt;=</span><span class="st"> </span><span class="fl">0.05</span>){</span>
<span id="cb11-32"><a href="#cb11-32"></a>      test2 &lt;-<span class="st"> </span><span class="kw">wilcox.test</span>(<span class="kw">unlist</span>(<span class="kw">cbind</span>(data1, data2)[<span class="dv">1</span>, ]), <span class="kw">unlist</span>(data1[<span class="dv">2</span>, ]),</span>
<span id="cb11-33"><a href="#cb11-33"></a>                           <span class="dt">alternative =</span> alternative, <span class="dt">mu =</span> mu, <span class="dt">paired =</span> <span class="ot">FALSE</span>,</span>
<span id="cb11-34"><a href="#cb11-34"></a>                           <span class="dt">conf.int =</span> <span class="ot">TRUE</span>, <span class="dt">conf.level =</span> conf.level)</span>
<span id="cb11-35"><a href="#cb11-35"></a>    }<span class="cf">else</span>{</span>
<span id="cb11-36"><a href="#cb11-36"></a>      <span class="cf">if</span>(<span class="kw">var.test</span>(<span class="kw">unlist</span>(<span class="kw">cbind</span>(data1, data2)[<span class="dv">1</span>, ]), <span class="kw">unlist</span>(data1[<span class="dv">2</span>, ]))<span class="op">$</span></span>
<span id="cb11-37"><a href="#cb11-37"></a><span class="st">         </span>p.value <span class="op">&lt;=</span><span class="st"> </span><span class="fl">0.05</span>){</span>
<span id="cb11-38"><a href="#cb11-38"></a>        test2 &lt;-<span class="st"> </span><span class="kw">t.test</span>(<span class="kw">cbind</span>(data1, data2)[<span class="dv">1</span>, ], data1[<span class="dv">2</span>, ],</span>
<span id="cb11-39"><a href="#cb11-39"></a>                        <span class="dt">alternative =</span> alternative, <span class="dt">mu =</span> mu, </span>
<span id="cb11-40"><a href="#cb11-40"></a>                        <span class="dt">conf.level =</span> conf.level, <span class="dt">paired =</span> <span class="ot">FALSE</span>, </span>
<span id="cb11-41"><a href="#cb11-41"></a>                        <span class="dt">var.equal =</span> <span class="ot">FALSE</span>)</span>
<span id="cb11-42"><a href="#cb11-42"></a>      }<span class="cf">else</span>{</span>
<span id="cb11-43"><a href="#cb11-43"></a>        test2 &lt;-<span class="st"> </span><span class="kw">t.test</span>(<span class="kw">cbind</span>(data1, data2)[<span class="dv">1</span>, ], data1[<span class="dv">2</span>, ],</span>
<span id="cb11-44"><a href="#cb11-44"></a>                            <span class="dt">alternative =</span> alternative, <span class="dt">mu =</span> mu, </span>
<span id="cb11-45"><a href="#cb11-45"></a>                            <span class="dt">conf.level =</span> conf.level, <span class="dt">paired =</span> <span class="ot">FALSE</span>, </span>
<span id="cb11-46"><a href="#cb11-46"></a>                            <span class="dt">var.equal =</span> <span class="ot">TRUE</span>)</span>
<span id="cb11-47"><a href="#cb11-47"></a>      }</span>
<span id="cb11-48"><a href="#cb11-48"></a>    }</span>
<span id="cb11-49"><a href="#cb11-49"></a>  }</span>
<span id="cb11-50"><a href="#cb11-50"></a>}</span></code></pre></div>
</div>
<div id="n_10-n_20-n_30-4" class="section level3">
<h3>8. <span class="math inline">\(n_1&gt;0,\, n_2=0,\, n_3&gt;0\)</span></h3>
<p>The last special case is identical to the previous one except that the input dataset is a combined data of <code>data1</code> and <code>data3</code>.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb12-1"><a href="#cb12-1"></a><span class="cf">if</span>(n1 <span class="op">&gt;</span><span class="st"> </span><span class="dv">0</span> <span class="op">&amp;</span><span class="st"> </span>n2 <span class="op">==</span><span class="st"> </span><span class="dv">0</span> <span class="op">&amp;</span><span class="st"> </span>n3 <span class="op">&gt;</span><span class="st"> </span><span class="dv">0</span>){</span>
<span id="cb12-2"><a href="#cb12-2"></a>  <span class="cf">if</span>(<span class="kw">shapiro.test</span>(<span class="kw">unlist</span>(data1[<span class="dv">1</span>, ]))<span class="op">$</span>p.value <span class="op">&lt;=</span><span class="st"> </span><span class="fl">0.05</span> <span class="op">|</span></span>
<span id="cb12-3"><a href="#cb12-3"></a><span class="st">     </span><span class="kw">shapiro.test</span>(<span class="kw">unlist</span>(data1[<span class="dv">2</span>, ]))<span class="op">$</span>p.value <span class="op">&lt;=</span><span class="st"> </span><span class="fl">0.05</span>){</span>
<span id="cb12-4"><a href="#cb12-4"></a>    test1 &lt;-<span class="st"> </span><span class="kw">wilcox.test</span>(<span class="kw">unlist</span>(data1[<span class="dv">1</span>, ]), <span class="kw">unlist</span>(data1[<span class="dv">2</span>, ]),</span>
<span id="cb12-5"><a href="#cb12-5"></a>                         <span class="dt">alternative =</span> alternative, <span class="dt">mu =</span> mu, <span class="dt">paired =</span> <span class="ot">TRUE</span>,</span>
<span id="cb12-6"><a href="#cb12-6"></a>                         <span class="dt">conf.int =</span> <span class="ot">TRUE</span>, <span class="dt">conf.level =</span> conf.level)</span>
<span id="cb12-7"><a href="#cb12-7"></a>    <span class="cf">if</span>(<span class="kw">shapiro.test</span>(<span class="kw">unlist</span>(<span class="kw">cbind</span>(data1, data3)[<span class="dv">2</span>, ]))<span class="op">$</span>p.value <span class="op">&lt;=</span><span class="st"> </span><span class="fl">0.05</span> <span class="op">|</span></span>
<span id="cb12-8"><a href="#cb12-8"></a><span class="st">       </span><span class="kw">shapiro.test</span>(<span class="kw">unlist</span>(data1[<span class="dv">1</span>, ]))<span class="op">$</span>p.value <span class="op">&lt;=</span><span class="st"> </span><span class="fl">0.05</span>){</span>
<span id="cb12-9"><a href="#cb12-9"></a>      test2 &lt;-<span class="st"> </span><span class="kw">wilcox.test</span>(<span class="kw">unlist</span>(<span class="kw">cbind</span>(data1, data3)[<span class="dv">2</span>, ]), <span class="kw">unlist</span>(data1[<span class="dv">1</span>, ]),</span>
<span id="cb12-10"><a href="#cb12-10"></a>                           <span class="dt">alternative =</span> alternative, <span class="dt">mu =</span> mu, <span class="dt">paired =</span> <span class="ot">FALSE</span>,</span>
<span id="cb12-11"><a href="#cb12-11"></a>                           <span class="dt">conf.int =</span> <span class="ot">TRUE</span>, <span class="dt">conf.level =</span> conf.level)  </span>
<span id="cb12-12"><a href="#cb12-12"></a>    }<span class="cf">else</span>{</span>
<span id="cb12-13"><a href="#cb12-13"></a>      <span class="cf">if</span>(<span class="kw">var.test</span>(<span class="kw">unlist</span>(<span class="kw">cbind</span>(data1, data3)[<span class="dv">2</span>, ]), <span class="kw">unlist</span>(data1[<span class="dv">1</span>, ]))<span class="op">$</span></span>
<span id="cb12-14"><a href="#cb12-14"></a><span class="st">         </span>p.value <span class="op">&lt;=</span><span class="st"> </span><span class="fl">0.05</span>){</span>
<span id="cb12-15"><a href="#cb12-15"></a>        test2 &lt;-<span class="st"> </span><span class="kw">t.test</span>(<span class="kw">cbind</span>(data1, data3)[<span class="dv">2</span>, ], data1[<span class="dv">1</span>, ],</span>
<span id="cb12-16"><a href="#cb12-16"></a>                        <span class="dt">alternative =</span> alternative, <span class="dt">mu =</span> mu, </span>
<span id="cb12-17"><a href="#cb12-17"></a>                        <span class="dt">conf.level =</span> conf.level, <span class="dt">paired =</span> <span class="ot">FALSE</span>,</span>
<span id="cb12-18"><a href="#cb12-18"></a>                        <span class="dt">var.equal =</span> <span class="ot">FALSE</span>)</span>
<span id="cb12-19"><a href="#cb12-19"></a>      }<span class="cf">else</span>{</span>
<span id="cb12-20"><a href="#cb12-20"></a>        test2 &lt;-<span class="st"> </span><span class="kw">t.test</span>(<span class="kw">cbind</span>(data1, data3)[<span class="dv">2</span>, ], data1[<span class="dv">1</span>, ],</span>
<span id="cb12-21"><a href="#cb12-21"></a>                        <span class="dt">alternative =</span> alternative, <span class="dt">mu =</span> mu, </span>
<span id="cb12-22"><a href="#cb12-22"></a>                        <span class="dt">conf.level =</span> conf.level, <span class="dt">paired =</span> <span class="ot">FALSE</span>, </span>
<span id="cb12-23"><a href="#cb12-23"></a>                        <span class="dt">var.equal =</span> <span class="ot">TRUE</span>)</span>
<span id="cb12-24"><a href="#cb12-24"></a>      }</span>
<span id="cb12-25"><a href="#cb12-25"></a>    }</span>
<span id="cb12-26"><a href="#cb12-26"></a>  }<span class="cf">else</span>{</span>
<span id="cb12-27"><a href="#cb12-27"></a>    test1 &lt;-<span class="st"> </span><span class="kw">t.test</span>(<span class="kw">unlist</span>(data1[<span class="dv">1</span>, ]), <span class="kw">unlist</span>(data1[<span class="dv">2</span>, ]), </span>
<span id="cb12-28"><a href="#cb12-28"></a>                    <span class="dt">alternative =</span> alternative, <span class="dt">mu =</span> mu, <span class="dt">conf.level =</span> conf.level,</span>
<span id="cb12-29"><a href="#cb12-29"></a>                    <span class="dt">paired =</span> <span class="ot">TRUE</span>, <span class="dt">var.equal =</span> <span class="ot">FALSE</span>)</span>
<span id="cb12-30"><a href="#cb12-30"></a>    <span class="cf">if</span>(<span class="kw">shapiro.test</span>(<span class="kw">unlist</span>(<span class="kw">cbind</span>(data1, data3)[<span class="dv">2</span>, ]))<span class="op">$</span>p.value <span class="op">&lt;=</span><span class="st"> </span><span class="fl">0.05</span> <span class="op">|</span></span>
<span id="cb12-31"><a href="#cb12-31"></a><span class="st">       </span><span class="kw">shapiro.test</span>(<span class="kw">unlist</span>(data1[<span class="dv">1</span>, ]))<span class="op">$</span>p.value <span class="op">&lt;=</span><span class="st"> </span><span class="fl">0.05</span>){</span>
<span id="cb12-32"><a href="#cb12-32"></a>      test2 &lt;-<span class="st"> </span><span class="kw">wilcox.test</span>(<span class="kw">unlist</span>(<span class="kw">cbind</span>(data1, data3)[<span class="dv">2</span>, ]), <span class="kw">unlist</span>(data1[<span class="dv">1</span>, ]),</span>
<span id="cb12-33"><a href="#cb12-33"></a>                           <span class="dt">alternative =</span> alternative, <span class="dt">mu =</span> mu, <span class="dt">paired =</span> <span class="ot">FALSE</span>,</span>
<span id="cb12-34"><a href="#cb12-34"></a>                           <span class="dt">conf.int =</span> <span class="ot">TRUE</span>, <span class="dt">conf.level =</span> conf.level)</span>
<span id="cb12-35"><a href="#cb12-35"></a>    }<span class="cf">else</span>{</span>
<span id="cb12-36"><a href="#cb12-36"></a>      <span class="cf">if</span>(<span class="kw">var.test</span>(<span class="kw">unlist</span>(<span class="kw">cbind</span>(data1, data3)[<span class="dv">2</span>, ]), <span class="kw">unlist</span>(data1[<span class="dv">1</span>, ]))<span class="op">$</span></span>
<span id="cb12-37"><a href="#cb12-37"></a><span class="st">         </span>p.value <span class="op">&lt;=</span><span class="st"> </span><span class="fl">0.05</span>){</span>
<span id="cb12-38"><a href="#cb12-38"></a>        test2 &lt;-<span class="st"> </span><span class="kw">t.test</span>(<span class="kw">cbind</span>(data1, data3)[<span class="dv">2</span>, ], data1[<span class="dv">1</span>, ],</span>
<span id="cb12-39"><a href="#cb12-39"></a>                        <span class="dt">alternative =</span> alternative, <span class="dt">mu =</span> mu, </span>
<span id="cb12-40"><a href="#cb12-40"></a>                        <span class="dt">conf.level =</span> conf.level, <span class="dt">paired =</span> <span class="ot">FALSE</span>, </span>
<span id="cb12-41"><a href="#cb12-41"></a>                        <span class="dt">var.equal =</span> <span class="ot">FALSE</span>)</span>
<span id="cb12-42"><a href="#cb12-42"></a>      }<span class="cf">else</span>{</span>
<span id="cb12-43"><a href="#cb12-43"></a>        test2 &lt;-<span class="st"> </span><span class="kw">t.test</span>(<span class="kw">cbind</span>(data1, data3)[<span class="dv">2</span>, ], data1[<span class="dv">1</span>, ],</span>
<span id="cb12-44"><a href="#cb12-44"></a>                            <span class="dt">alternative =</span> alternative, <span class="dt">mu =</span> mu, </span>
<span id="cb12-45"><a href="#cb12-45"></a>                            <span class="dt">conf.level =</span> conf.level, <span class="dt">paired =</span> <span class="ot">FALSE</span>, </span>
<span id="cb12-46"><a href="#cb12-46"></a>                            <span class="dt">var.equal =</span> <span class="ot">TRUE</span>)</span>
<span id="cb12-47"><a href="#cb12-47"></a>      }</span>
<span id="cb12-48"><a href="#cb12-48"></a>    }</span>
<span id="cb12-49"><a href="#cb12-49"></a>  }</span>
<span id="cb12-50"><a href="#cb12-50"></a>}</span></code></pre></div>
</div>
</div>
<div id="statistical-analysis-methods-for-partially-matched-samples." class="section level2">
<h2>Statistical Analysis Methods for Partially Matched Samples<a href="#fn2" class="footnote-ref" id="fnref2"><sup>2</sup></a>.</h2>
<p>After inspecting and providing solutions for the special cases that users may encounter, it is ready to discuss implementations for partially matched samples. Detailed implementation for partially matched samples will not be shown in this manual because the implementation is straightforward. More information can be found in the source code and the help files of the functions. The more critical information - the methods to handle partially matched samples - will be discussed in detail.</p>
<p>Partially matched samples correspond to the case <span class="math inline">\(n_1&gt;0,\, n_2&gt;0,\, n_3&gt;0\)</span>. There are two options for users to select if only standard complete analysis procedures are provided for analyzing partially matched samples <span class="citation">[<a href="#ref-kuan" role="doc-biblioref">1</a>]</span>:</p>
<ul>
<li>Only analyze the <span class="math inline">\(n_1\)</span> matched samples <code>data1</code> using paired-sample methods</li>
<li>Treat <span class="math inline">\(n_1+n_2\)</span> samples (the first samples of the combined data of <code>data1</code> and <code>data2</code>) and <span class="math inline">\(n_1+n_3\)</span> samples (the second samples of the combined data of <code>data1</code> and <code>data3</code> ) as two independent samples.</li>
</ul>
<p>Kuan and Huang claim <span class="citation">[<a href="#ref-kuan" role="doc-biblioref">1</a>]</span> that the above approaches are not the best choices because paired-sample methods for a subset of data do not utilize all the information given in the original data, whereas considering the partially matched samples as two independent samples may lose the inherent pair correlation structure between the matched samples. Thus, five types of statistical analysis strategies are developed for analyzing partially matched samples.</p>
<div id="liptaks-weighted-z-test" class="section level3">
<h3>Liptak’s Weighted Z-Test</h3>
<p>Given a dataset of partially matched samples, let <span class="math inline">\(p_{1i}\)</span> be the p-value of <span class="math inline">\(n_1\)</span> matched samples <code>data1</code> using paired-sample methods and <span class="math inline">\(p_{2i}\)</span> be the p-value of two independent samples methods of <span class="math inline">\(n_2\)</span> Sample 1 (the first samples of <code>data2</code>) and <span class="math inline">\(n_3\)</span> Sample 2 (the second samples of <code>data3</code>). Liptak’s weighted Z-test statistics are <span class="math inline">\(Z_{1i}=\Phi^{-1}(1-p_{1i})\)</span> and <span class="math inline">\(Z_{2i}=\Phi^{-1}(1-p_{2i})\)</span>, where <span class="math inline">\(\Phi^{-1}(x)\)</span> is the inverse standard normal cumulative distribution function of <span class="math inline">\(x\)</span>. The combined p-value of Liptak’s weighted Z-test <span class="citation">[<a href="#ref-liptak" role="doc-biblioref">2</a>]</span> is given by <span class="math display">\[\begin{equation}
p_{ci}=1-\Phi{\left(\frac{w_1Z_{1i}+w_2Z_{2i}}{\sqrt{w_1^2+w_2^2}}\right)},
\end{equation}\]</span> where <span class="math inline">\(\Phi(x)\)</span> is the standard normal cumulative distribution function of <span class="math inline">\(x\)</span>. <span class="math inline">\(w_1\)</span> and <span class="math inline">\(w_2\)</span> are the weights for the first and the second p-values, respectively. There are several choices of weights. Liptak <span class="citation">[<a href="#ref-liptak" role="doc-biblioref">2</a>]</span> proposed the default weights as <span class="math inline">\(w_1=\sqrt{2n_1}\)</span> and <span class="math inline">\(w_2=\sqrt{n_2+n_3}\)</span>.</p>
<p>It is important to remark that the combined p-value above is meaningful only when <span class="math inline">\(p_{1i}\)</span> and <span class="math inline">\(p_{2i}\)</span> are one-sided p-values <span class="citation">[<a href="#ref-kuan" role="doc-biblioref">1</a>]</span>. If a two-sided combined p-value is preferred, Zaykin <span class="citation">[<a href="#ref-zaykin" role="doc-biblioref">3</a>]</span> suggests obtaining one-sided (either “greater” or “less”) p-values <span class="math inline">\(p_{1i}\)</span> and <span class="math inline">\(p_{2i}\)</span> first. Then the one-sided combined p-value can be obtained using the above formula. Finally, adjust the one-sided combined p-value <span class="math inline">\(p_{ci}\)</span> to obtain a two-sided combined p-value <span class="math inline">\(p_{ci}^*\)</span> using</p>
<p><span class="math display">\[\begin{equation}
p_{ci}^*=
\begin{cases} 
2p_{ci}, &amp; \mbox{if }p_{ci}&lt;1/2 \\
2(1-p_{ci}), &amp; \mbox{otherwise}
\end{cases}.
\end{equation}\]</span></p>
</div>
<div id="kim-et-al.s-modified-t-statistic" class="section level3">
<h3>Kim et al.’s Modified t-Statistic</h3>
<p>Let <span class="math inline">\(\bar{D}\)</span> and <span class="math inline">\(S_D\)</span> be the mean and the standard deviation of the difference of Sample 1 and Sample 2 in <code>data1</code>. Also, let <span class="math inline">\(\bar{T}\)</span> and <span class="math inline">\(S_T\)</span> be the mean and the standard deviation of Sample 1 in <code>data2</code>. Similarly define <span class="math inline">\(\bar{N}\)</span> and <span class="math inline">\(S_N\)</span> for Sample 2 in <code>data3</code>. Moreover, let <span class="math inline">\(n_H=\frac{2}{1/n_2+1/n_3}\)</span>. Then, Kim et al.’s modified t-statistic <span class="citation">[<a href="#ref-kim" role="doc-biblioref">4</a>]</span> is given by</p>
<p><span class="math display">\[\begin{equation}
t_3=\frac{n_1\bar{D}+n_H(\bar{T}-\bar{N})}{\sqrt{n_1S_D^2+n_H^2(S_T^2/n_2+S_N^2/n_3)}}.
\end{equation}\]</span></p>
<p>Note that the distribution of <span class="math inline">\(t_3\)</span> approximately follows a standard normal distribution under the null hypothesis <span class="citation">[<a href="#ref-kuan" role="doc-biblioref">1</a>]</span>. Therefore, p-values and confidence intervals can be obtained from <span class="math inline">\(t_3\)</span>.</p>
</div>
<div id="looney-and-joness-corrected-z-test" class="section level3">
<h3>Looney and Jones’s Corrected Z-Test</h3>
<p>Let <span class="math inline">\(\bar{T}^*\)</span> and <span class="math inline">\(S_T^*\)</span> be the mean and the standard deviation of Sample 1 in the combined data of <code>data1</code> and <code>data2</code>. Similarly define <span class="math inline">\(\bar{N}^*\)</span> and <span class="math inline">\(S_N^*\)</span> for Sample 2 in the combined data of <code>data1</code> and <code>data3</code>. Moreover, let <span class="math inline">\(S_{TN_1}\)</span> be the sample covariance of Sample 1 and Sample 2 in <code>data1</code>. Then, Looney and Jones’s corrected Z-test <span class="citation">[<a href="#ref-looney" role="doc-biblioref">5</a>]</span> is given by</p>
<p><span class="math display">\[\begin{equation}
Z_{corr}=\frac{\bar{T}^*-\bar{N}^*}{\sqrt{{S_T^*}^2/(n_1+n_2)+{S_N^*}^2/(n_1+n_3)-2n_1S_{TN_1}/((n_1+n_2)(n_1+n_3))}}.
\end{equation}\]</span></p>
<p>Note that the distribution of <span class="math inline">\(Z_{corr}\)</span> follows a standard normal distribution. Therefore, p-values and confidence intervals can be obtained from <span class="math inline">\(Z_{corr}\)</span>.</p>
</div>
<div id="lin-and-stiverss-mle-based-test-under-heteroscedasticity" class="section level3">
<h3>Lin and Stivers’s MLE-Based Test under Heteroscedasticity</h3>
<p>Let <span class="math inline">\(\bar{T_1}\)</span> and <span class="math inline">\(S_{T_1}\)</span> be the mean and the standard deviation of Sample 1 in <code>data1</code>. Similarly define <span class="math inline">\(\bar{N_1}\)</span> and <span class="math inline">\(S_{N_1}\)</span> for Sample 2 in <code>data1</code>. Let <span class="math inline">\(\bar{T}\)</span> be the mean of Sample 1 in <code>data2</code>, as defined in Kim et al.’s modified t-statistic <span class="citation">[<a href="#ref-kim" role="doc-biblioref">4</a>]</span>. Similarly define <span class="math inline">\(\bar{N}\)</span> for Sample 2 in <code>data3</code>. Let <span class="math inline">\(S_{TN_1}\)</span> be the sample covariance of Sample 1 and Sample 2 in <code>data1</code>, as defined in Looney and Jones’s corrected Z-test <span class="citation">[<a href="#ref-looney" role="doc-biblioref">5</a>]</span>. Then, Lin and Stivers’s MLE-based test under heteroscedasticity <span class="citation">[<a href="#ref-lin" role="doc-biblioref">6</a>]</span> is given by</p>
<p><span class="math display">\[\begin{equation}
Z_{LS}=\frac{f(\bar{T}_1-\bar{T})-g(\bar{N}_1-\bar{N})+\bar{T}-\bar{N}}{\sqrt{V_1}},
\end{equation}\]</span></p>
<p>where</p>
<p><span class="math display">\[\begin{equation}
V_1=\frac{[f^2/n_1+(1-f)^2/n_2]S_{T_1}^2(n_1-1)+[g^2/n_1+(1-g)^2/n_3]S_{N_1}^2(n_1-1)-2fgS_{TN_1}(n_1-1)/n_1}{n_1-1},
\end{equation}\]</span></p>
<p><span class="math display">\[\begin{equation}
f=n_1(n_1+n_3+n_2S_{TN_1}/S_{T_1}^2)[(n_1+n_2)(n_1+n_3)-n_2n_3r^2]^{-1},
\end{equation}\]</span></p>
<p><span class="math display">\[\begin{equation}
g=n_1(n_1+n_2+n_3S_{TN_1}/S_{N_1}^2)[(n_1+n_2)(n_1+n_3)-n_2n_3r^2]^{-1},
\end{equation}\]</span></p>
<p><span class="math display">\[\begin{equation}
r=S_{TN_1}/(S_{T_1}S_{N_1}).
\end{equation}\]</span></p>
<p>Note that the distribution of <span class="math inline">\(Z_{LS}\)</span> approximately follows a <span class="math inline">\(t\)</span> distribution with <span class="math inline">\(n_1\)</span> degrees of freedom under the null hypothesis <span class="citation">[<a href="#ref-kuan" role="doc-biblioref">1</a>]</span>. Therefore, p-values and confidence intervals can be obtained from <span class="math inline">\(Z_{LS}\)</span>.</p>
</div>
<div id="ekbohms-mle-based-test-under-homoscedasticity" class="section level3">
<h3>Ekbohm’s MLE-Based Test under Homoscedasticity</h3>
<p>Let <span class="math inline">\(\bar{T_1}\)</span> and <span class="math inline">\(S_{T_1}\)</span> be the mean and the standard deviation of Sample 1 in <code>data1</code>, and <span class="math inline">\(r=S_{TN_1}/(S_{T_1}S_{N_1})\)</span>, as defined in Lin and Stivers’s MLE-based test under heteroscedasticity <span class="citation">[<a href="#ref-lin" role="doc-biblioref">6</a>]</span>. Similarly define <span class="math inline">\(\bar{N_1}\)</span> and <span class="math inline">\(S_{N_1}\)</span> for Sample 2 in <code>data1</code>. Let <span class="math inline">\(\bar{T}\)</span> and <span class="math inline">\(S_T\)</span> be the mean and the standard deviation of Sample 1 in <code>data2</code>, as defined in Kim et al.’s modified t-statistic <span class="citation">[<a href="#ref-kim" role="doc-biblioref">4</a>]</span>. Similarly define <span class="math inline">\(\bar{N}\)</span> and <span class="math inline">\(S_N\)</span> for Sample 2 in <code>data3</code>. Then, Ekbohm’s MLE-based test under homoscedasticity <span class="citation">[<a href="#ref-ekbohm" role="doc-biblioref">7</a>]</span> is given by <span class="math display">\[\begin{equation}
Z_E=\frac{f^*(\bar{T}_1-\bar{T})-g^*(\bar{N_1}-\bar{N})+\bar{T}-\bar{N}}{\sqrt{V^*_1}},
\end{equation}\]</span></p>
<p>where</p>
<p><span class="math display">\[\begin{equation}
V_1^*=\hat{\sigma}^2\frac{2n_1(1-r)+(n_2+n_3)(1-r^2)}{(n_1+n_2)(n_1+n_3)-n_2n_3r^2},
\end{equation}\]</span></p>
<p><span class="math display">\[\begin{equation}
\hat{\sigma}^2=\frac{S_{T_1}^2(n_1-1)+S_{N_1}^2(n_1-1)+(1+r^2)[S_T^2(n_2-1)+S_N^2(n_3-1)]}{2(n_1-1)+(1+r^2)(n_2+n_3-2)},
\end{equation}\]</span></p>
<p><span class="math display">\[\begin{equation}
f^*=n_1(n_1+n_3+n_2r)[(n_1+n_2)(n_1+n_3)-n_2n_3r^2]^{-1},
\end{equation}\]</span></p>
<p><span class="math display">\[\begin{equation}
g^*=n_1(n_1+n_2+n_3r)[(n_1+n_2)(n_1+n_3)-n_2n_3r^2]^{-1}.
\end{equation}\]</span></p>
<p>Note that the distribution of <span class="math inline">\(Z_E\)</span> approximately follows a <span class="math inline">\(t\)</span> distribution with <span class="math inline">\(n_1\)</span> degrees of freedom under the null hypothesis <span class="citation">[<a href="#ref-kuan" role="doc-biblioref">1</a>]</span>. Therefore, p-values and confidence intervals can be obtained from <span class="math inline">\(Z_E\)</span>.</p>
</div>
</div>
<div id="discussion-of-statistical-approaches-for-partially-matched-samples" class="section level2">
<h2>Discussion of Statistical Approaches for Partially Matched Samples</h2>
<p>It is important to realize that Liptak’s weighted Z-test <span class="citation">[<a href="#ref-liptak" role="doc-biblioref">2</a>]</span> is a p-values pooling strategy, and the rest of the methods illustrated in this manual <span class="citation">[<a href="#ref-kim" role="doc-biblioref">4</a>]</span><span class="citation">[<a href="#ref-looney" role="doc-biblioref">5</a>]</span><span class="citation">[<a href="#ref-lin" role="doc-biblioref">6</a>]</span><span class="citation">[<a href="#ref-ekbohm" role="doc-biblioref">7</a>]</span> are based on modified test statistics.</p>
<div id="p-values-pooling-strategies-vs.-modified-test-statistics-approaches-for-partially-matched-samples" class="section level3">
<h3>P-Values Pooling Strategies vs. Modified Test Statistics Approaches for Partially Matched Samples</h3>
<p>Note that the distribution of the modified test statistics methods discussed here follow either a standard normal distribution or a Student’s t-distribution. Therefore, Kuan and Huang <span class="citation">[<a href="#ref-kuan" role="doc-biblioref">1</a>]</span> state that the above four modified test statistics approaches <span class="citation">[<a href="#ref-kim" role="doc-biblioref">4</a>]</span><span class="citation">[<a href="#ref-looney" role="doc-biblioref">5</a>]</span><span class="citation">[<a href="#ref-lin" role="doc-biblioref">6</a>]</span><span class="citation">[<a href="#ref-ekbohm" role="doc-biblioref">7</a>]</span> may not be robust for nonnormal datasets that are small or moderate in size. Comparatively, because Liptak’s weighted Z-test <span class="citation">[<a href="#ref-liptak" role="doc-biblioref">2</a>]</span> considers p-values directly, which enables a more robust choice of hypothesis testing procedures. For example, if at least one of the two independent samples, <span class="math inline">\(n_2\)</span> Sample 1 (the first samples of <code>data2</code>) and <span class="math inline">\(n_3\)</span> Sample 2 (the second samples of <code>data3</code>), is not normal, the two independent samples using the two-sample Wilcoxon rank sum test method is a more robust nonparametric approach, rather than the two-sample t-test method. To summarize, p-values pooling strategies can be used directly to any statistical tests for both paired and independent samples <span class="citation">[<a href="#ref-kuan" role="doc-biblioref">1</a>]</span>.</p>
</div>
<div id="additional-comments-on-modified-test-statistics-methods" class="section level3">
<h3>Additional Comments on Modified Test Statistics Methods</h3>
<ol style="list-style-type: decimal">
<li><p>As the name of Kim et al.’s modified t-statistic <span class="citation">[<a href="#ref-kim" role="doc-biblioref">4</a>]</span> suggests, Kim et al.’s test statistic <span class="math inline">\(t_3\)</span> <span class="citation">[<a href="#ref-kim" role="doc-biblioref">4</a>]</span> is based on a modification of the standard t-test statistic. Looney and Jones’s corrected Z-test statistic <span class="math inline">\(Z_{corr}\)</span> <span class="citation">[<a href="#ref-looney" role="doc-biblioref">5</a>]</span> is based on a modified variance estimation of the standard Z-test <span class="citation">[<a href="#ref-kuan" role="doc-biblioref">1</a>]</span>.</p></li>
<li><p>The standard matched t-test method and the the two-sample t-test method are special cases of Looney and Jones’s corrected Z-test <span class="citation">[<a href="#ref-looney" role="doc-biblioref">5</a>]</span> when <span class="math inline">\(n_2=n_3=0\)</span> and <span class="math inline">\(n_1=0\)</span>, respectively <span class="citation">[<a href="#ref-kuan" role="doc-biblioref">1</a>]</span>.</p></li>
<li><p>Lin and Stivers’s <span class="citation">[<a href="#ref-lin" role="doc-biblioref">6</a>]</span> and Ekbohm’s <span class="citation">[<a href="#ref-ekbohm" role="doc-biblioref">7</a>]</span> tests are based on a modified maximum likelihood estimator (MMLE). More precisely, suppose that Sample 1 and Sample 2 are bivariate normal. Both procedures consider the MMLE of the two samples’ correlation mean difference <span class="citation">[<a href="#ref-kuan" role="doc-biblioref">1</a>]</span>. In particular, Lin and Stivers’s <span class="citation">[<a href="#ref-lin" role="doc-biblioref">6</a>]</span> work extends to the nonconstant variance case for Sample 1 and Sample 2. Ekbohm’s <span class="citation">[<a href="#ref-ekbohm" role="doc-biblioref">7</a>]</span> work concerns about the constant variance case.</p></li>
</ol>
</div>
</div>
<div id="examples" class="section level2">
<h2>Examples</h2>
<p>Partially matched samples analysis examples using the <code>pm</code> dataset in the <code>PMLi</code> package are illustrated here. The common function arguments in the <code>PMLi</code> package are <code>data</code>, <code>alternative</code>, <code>mu</code>, and <code>conf.level</code>. Liptak’s weighted Z-test <span class="citation">[<a href="#ref-liptak" role="doc-biblioref">2</a>]</span> has additional two parameters, <code>w1</code> and <code>w2</code>, for the weights of the p-values. Various components will be outputted. More details can be found in the help files of the functions.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb13-1"><a href="#cb13-1"></a><span class="co"># Run the following command if you have questions about weighted.z() function.</span></span>
<span id="cb13-2"><a href="#cb13-2"></a><span class="co"># ?weighted.z()</span></span></code></pre></div>
<div class="sourceCode" id="cb14"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb14-1"><a href="#cb14-1"></a><span class="co"># p-value is returned.</span></span>
<span id="cb14-2"><a href="#cb14-2"></a><span class="kw">weighted.z</span>(pm)<span class="op">$</span>p.value</span>
<span id="cb14-3"><a href="#cb14-3"></a><span class="co">#&gt; [1] 0.8922438</span></span></code></pre></div>
<div class="sourceCode" id="cb15"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb15-1"><a href="#cb15-1"></a><span class="co"># Formula interface is outputted.</span></span>
<span id="cb15-2"><a href="#cb15-2"></a><span class="kw">modified.t</span>(pm)</span>
<span id="cb15-3"><a href="#cb15-3"></a><span class="co">#&gt; </span></span>
<span id="cb15-4"><a href="#cb15-4"></a><span class="co">#&gt;  Kim et al.&#39;s modified t-statistic</span></span>
<span id="cb15-5"><a href="#cb15-5"></a><span class="co">#&gt; </span></span>
<span id="cb15-6"><a href="#cb15-6"></a><span class="co">#&gt; data:  pm</span></span>
<span id="cb15-7"><a href="#cb15-7"></a><span class="co">#&gt; t_3 = 0.81777, p-value = 0.4135</span></span>
<span id="cb15-8"><a href="#cb15-8"></a><span class="co">#&gt; alternative hypothesis: true difference in means is not equal to 0</span></span>
<span id="cb15-9"><a href="#cb15-9"></a><span class="co">#&gt; 95 percent confidence interval:</span></span>
<span id="cb15-10"><a href="#cb15-10"></a><span class="co">#&gt;  -0.7658655  1.8625286</span></span>
<span id="cb15-11"><a href="#cb15-11"></a><span class="co">#&gt; sample estimates:</span></span>
<span id="cb15-12"><a href="#cb15-12"></a><span class="co">#&gt; difference in means </span></span>
<span id="cb15-13"><a href="#cb15-13"></a><span class="co">#&gt;           0.5483315</span></span></code></pre></div>
<div class="sourceCode" id="cb16"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb16-1"><a href="#cb16-1"></a><span class="co"># Test statistic is returned.</span></span>
<span id="cb16-2"><a href="#cb16-2"></a><span class="kw">corrected.z</span>(pm, <span class="st">&quot;greater&quot;</span>)<span class="op">$</span>statistic</span>
<span id="cb16-3"><a href="#cb16-3"></a><span class="co">#&gt;    Z_corr </span></span>
<span id="cb16-4"><a href="#cb16-4"></a><span class="co">#&gt; 0.8343486</span></span></code></pre></div>
<div class="sourceCode" id="cb17"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb17-1"><a href="#cb17-1"></a><span class="co"># Confidence interval is returned with specified arguments.</span></span>
<span id="cb17-2"><a href="#cb17-2"></a><span class="kw">mle.hetero</span>(pm, <span class="dt">alternative =</span> <span class="st">&quot;less&quot;</span>, <span class="dt">conf.level =</span> <span class="fl">0.90</span>)<span class="op">$</span>conf.int</span>
<span id="cb17-3"><a href="#cb17-3"></a><span class="co">#&gt; [1]        -Inf 0.009921201</span></span>
<span id="cb17-4"><a href="#cb17-4"></a><span class="co">#&gt; attr(,&quot;conf.level&quot;)</span></span>
<span id="cb17-5"><a href="#cb17-5"></a><span class="co">#&gt; [1] 0.9</span></span></code></pre></div>
<div class="sourceCode" id="cb18"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb18-1"><a href="#cb18-1"></a><span class="co"># Formula interface is returned with specified arguments.</span></span>
<span id="cb18-2"><a href="#cb18-2"></a><span class="kw">mle.homo</span>(pm, <span class="dt">alternative =</span> <span class="st">&quot;greater&quot;</span>, <span class="dt">mu =</span> <span class="fl">0.01</span>, <span class="dt">conf.level =</span> <span class="fl">0.99</span>)</span>
<span id="cb18-3"><a href="#cb18-3"></a><span class="co">#&gt; </span></span>
<span id="cb18-4"><a href="#cb18-4"></a><span class="co">#&gt;  Ekbohm&#39;s MLE-based test under homoscedasticity</span></span>
<span id="cb18-5"><a href="#cb18-5"></a><span class="co">#&gt; </span></span>
<span id="cb18-6"><a href="#cb18-6"></a><span class="co">#&gt; data:  pm</span></span>
<span id="cb18-7"><a href="#cb18-7"></a><span class="co">#&gt; Z_E = -1.4301, df = 100, p-value = 0.9221</span></span>
<span id="cb18-8"><a href="#cb18-8"></a><span class="co">#&gt; alternative hypothesis: true difference in means is greater than 0.01</span></span>
<span id="cb18-9"><a href="#cb18-9"></a><span class="co">#&gt; 99 percent confidence interval:</span></span>
<span id="cb18-10"><a href="#cb18-10"></a><span class="co">#&gt;  -0.007069962          Inf</span></span>
<span id="cb18-11"><a href="#cb18-11"></a><span class="co">#&gt; sample estimates:</span></span>
<span id="cb18-12"><a href="#cb18-12"></a><span class="co">#&gt; difference in means </span></span>
<span id="cb18-13"><a href="#cb18-13"></a><span class="co">#&gt;         0.003566155</span></span></code></pre></div>
</div>
<div id="references" class="section level2 unnumbered">
<h2>References</h2>
<div id="refs" class="references">
<div id="ref-kuan">
<p>1. Kuan PF, Huang B. A simple and robust method for partially matched samples using the p-values pooling approach. <em>Statistics in medicine</em> 2013 ; 32: 3247–3259.</p>
</div>
<div id="ref-liptak">
<p>2. Liptak T. On the combination of independent tests. <em>Magyar Tudom Aanyos Akad Aemia Matematikai Kutat Ao Intezetenek Kozlemenyei</em> 1958 ; 3: 171–197.</p>
</div>
<div id="ref-zaykin">
<p>3. Zaykin D. Optimally weighted z-test is a powerful method for combining probabilities in meta-analysis. <em>Journal of Evolutional Biology</em> 2011 ; 24: 1836–1841.</p>
</div>
<div id="ref-kim">
<p>4. Kim B, Kim I, Lee S <em>et al.</em> A simple and robust method for partially matched samples using the p-values pooling approach. <em>Bioinformatics</em> 2004 ; 21: 517–528.</p>
</div>
<div id="ref-looney">
<p>5. Looney S, Jones PW. A method for comparing two normal means using combined samples of correlated and uncorrelated data. <em>Statistics in Medicine</em> 2003 ; 22: 1601–1610.</p>
</div>
<div id="ref-lin">
<p>6. Lin P, Stivers LE. On differences of means with incomplete data. <em>Biometrika</em> 1974 ; 61: 325–334.</p>
</div>
<div id="ref-ekbohm">
<p>7. Ekbohm G. On comparing means in the paired case with incomplete data on both responses. <em>Biometrika</em> 1976 ; 63: 299–304.</p>
</div>
</div>
</div>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>Note that some of the code presented in this user manual has been simplified for illustration purposes. For the actual implementation, please refer to the source code files.<a href="#fnref1" class="footnote-back">↩︎</a></p></li>
<li id="fn2"><p>For a complete statistical analysis strategies for partially matched samples, see Kuan and Huang’s <span class="citation">[<a href="#ref-kuan" role="doc-biblioref">1</a>]</span> article <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3717400/">here</a><a href="#fnref2" class="footnote-back">↩︎</a></p></li>
</ol>
</div>



<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
